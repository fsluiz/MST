# Quantum Walk-Based Minimum Spanning Tree Algorithm

This repository implements a quantum-inspired algorithm to calculate a Minimum Spanning Tree (MST) using quantum walks and compare it with classical algorithms, such as Kruskal's MST algorithm.

---

## **Features**
- Create complete graphs with random edge weights.
- Compute Hamiltonians based on the Laplacian of a graph.
- Simulate quantum walks for a graph.
- Calculate transition probabilities between graph nodes during a quantum walk.
- Generate MSTs using:
  - Transition probabilities from a quantum walk.
  - Classical Kruskal's algorithm (for comparison).
- Visualize the MSTs and graph structures.
- Analyze and plot transition probabilities over time.

---

## **Getting Started**

### **Prerequisites**
To run the code, you need the following Python libraries installed:
- **`networkx`**: For graph operations.
- **`numpy`**: For numerical computations.
- **`qutip`**: For quantum state and operator computations.
- **`matplotlib`**: For plotting graphs and probabilities.

Install the dependencies using:
```bash
pip install networkx numpy qutip matplotlib
```

---

### **Usage**

1. **Create a Complete Graph**
   The graph is created with random edge weights:
   ```python
   graph = create_complete_graph(num_nodes=5)
   ```

2. **Simulate a Quantum Walk**
   Compute the quantum evolution operator and transition probabilities:
   ```python
   t_max = 0.001  # Maximum evolution time
   probs = prob_transition(graph, t_max, num_nodes=len(graph.nodes))
   ```

3. **Generate MSTs**
   - Using quantum walks:
     ```python
     quantum_mst_edges = quantum_walk_mst(graph, t_max)
     ```
   - Using Kruskal's algorithm:
     ```python
     kruskal_mst_edges = kruskal_mst(graph)
     ```

4. **Visualize the MSTs**
   Plot the MSTs generated by both methods:
   ```python
   plot_mst(graph, quantum_mst_edges, "Quantum Walk MST")
   plot_mst(graph, kruskal_mst_edges, "Kruskal MST")
   ```

5. **Analyze Transition Probabilities Over Time**
   Compute and plot transition probabilities over a range of times:
   ```python
   times = np.linspace(0.001, 1, 100)  # Time range
   probs_over_time = calculate_probabilities_over_time(graph, times, num_nodes)
   plot_probabilities_over_time(times, probs_over_time, num_nodes)
   ```

---

### **Code Description**

- **Graph Construction**
  - `create_complete_graph(num_nodes)`: Generates a complete graph with randomly assigned edge weights.

- **Quantum Walk**
  - `construct_hamiltonian(graph)`: Constructs a Hamiltonian based on the graph's Laplacian matrix.
  - `quantum_walk(graph, t_max)`: Computes the quantum evolution operator for a given graph and time.

- **Transition Probabilities**
  - `prob_transition(graph, t_max, num_nodes)`: Calculates transition probabilities between graph nodes based on quantum walk dynamics.

- **MST Generation**
  - `quantum_walk_mst(graph, t_max)`: Builds an MST using transition probabilities derived from the quantum walk.
  - `kruskal_mst(graph)`: Builds an MST using Kruskal's algorithm.

- **Visualization**
  - `plot_mst(graph, mst_edges, title)`: Visualizes the graph and its MST with edge weights.
  - `plot_probabilities_over_time(times, probs_over_time, num_nodes)`: Plots the variation of transition probabilities over time.

---

### **Example Output**
The script provides:
- Plots of MSTs for both quantum walk-based and Kruskal algorithms.
- A comparison of the total weights of MSTs generated by the two methods.
- Visualization of transition probabilities over time.

```bash
Peso total da MST (Kruskal): 45
Peso total da MST (Caminhada QuÃ¢ntica): 47
```

---

### **Future Improvements**
- Optimize the computation of transition probabilities.
- Extend the algorithm for directed or weighted graphs with specific constraints.
- Integrate the algorithm into a larger quantum optimization framework.

---

### **License**
This project is licensed under the MIT License. Feel free to use and modify the code for academic and personal purposes.

---

Enjoy experimenting with quantum-inspired algorithms for graph problems! ðŸ˜Š
